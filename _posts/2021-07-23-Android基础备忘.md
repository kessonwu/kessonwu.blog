---
layout:     post
title:      Android基础备忘
subtitle:   全面回顾
date:       2021-07-23
author:     K
header-img: img/post-bg-desk.jpg
catalog: true
tags:
    - Android
---

# 第一部分、Java基础


## 一、内存分配

方法区、堆、虚拟机栈、本地方法栈、程序计数器

其中方法区、堆为公共内存区域，虚拟机栈、本地方法栈、程序计数器为线程私有

### 1 程序计数器PC

记录正在执行的虚拟机字节码指令的地址，线程切换时，处理器根据PC还原到需执行的位置

JVM基于栈，DVM基于寄存器，栈指令紧凑，寄存器指令长但指令数少(比如少了压/出栈指令)

### 2 虚拟机栈

虚拟机栈是线程私有的，是由栈帧组成的栈，栈顶帧为活动栈，
方法调用其他方法时，会将对应栈帧压倒栈顶，执行完后弹出，直至所有栈帧弹出，线程结束

栈帧是用于给虚拟机进行方法调用和方法执行的**数据结构**，每个方法调用产生一个栈帧，
每个栈帧包含局部变量表、操作数栈、动态链接、返回地址等，一个栈帧对应一个方法，对应多条指令(操作数)

动态链接是指向运行时常量池的方法引用，支持方法调用过程中将class文件中的符号引用转化为直接引用

class文件中的符号引用，在类解析阶段，或第一次使用时转化未直接引用，称为静态解析；在运行时转化为直接引用，称为动态链接

返回地址保存了方法正常退出时的PC计数值，方法异常退出时，返回地址是异常处理器表确定的，不保存在栈帧中

本地方法栈与虚拟机栈类似，只不过针对native方法

### 4 堆

方法的实例都分配在此区域，是垃圾回收GC管理的主要区域，一般分为新生代和老年代，新生代又分为eden、survivor0、survivor1

### 5 方法区

存储已被JVM加载的类信息(版本、字段、方法、接口)、常量、静态变量、代码

方法区是规范层的定义，永久区是HotSpot在JDK1.7及以下的实现，1.8后改为元空间实现


## 二、GC回收

### 可达性分析

JVM把内存中对象之间的引用关系看做一张图(离散图论)，由多颗有向树组成，树的根节点称为GC Root

从GC Root开始向下搜索，搜索所经过的路径称为引用链，通过引用链是否可达来判断对象是否可以回收

GC Root包括以下对象：
- 虚拟机栈中本地变量表所引用的对象
- 本地方法栈中本地变量表所引用的对象
- 方法区中静态引用指向的对象(包括常量)
- 仍处于存活状态的线程对象

回收时机：因内存不足导致的内存分配失败、主动调用System.gc()

### 内存回收算法

标记清除 Mark and Sweep
- 标记：从GC Root开始全部遍历，被引用的标记为灰色(存活)，否则标记成黑色(垃圾)
- 清除：遍历完成后，将垃圾全部清除
实现简单，不需要进行对象移动；需要stop the world，会产生内存碎片

复制算法 Copying
- 内存分为两块，一次用一块
- 在用的一块进行标记
- 标记完存活的全部拷贝到另一块
- 切换第二块为使用内存，并清除之前块的所有对象
无内存碎片；内存会缩小为一半，存活率高时复制频繁

标记-压缩 Mark-Compact
- 标记：同标记清除
- 压缩：将存活对象按顺序压缩到内存另一端
无内存碎片，不需要内存减半；仍然有对象移动，效率一般

分代回收机制
JVM一半分为新生代、老年代，HotSpot多定义了一个永久代<br>
新生代默认按8:1:1分为eden、survivor0、survivor1<br>
一般新生代因为存活率低采用复制算法，老年代采用MS或MC

### GC称谓
- young GC/minor GC: 回收新生代
- old GC: 回收老年代
- full GC: 收集整个堆

### Hotspot回收器
- Serial(JDK1.3之前)，单线程，用于新生代，复制算法，一旦启动，stop the world，多用于client
- Serial Old，用于老年代，标记清除算法，其余同上
- ParNew，Serial的多线程版本，同样也要stop all
- CMS(Concurrent Mark Sweep，JDK1.5起)，初始标记、并发标记、重新标记、并发清除，其中初标和重标仍然需要stop，其余可与用户程序
并发工作。CMS无法处理浮动垃圾，即并发运行的用户程序在标记过程中产生的垃圾。
CMS需预留一些空间进行整理，如果预留空间不足，则会抛出Concurrent Mode Failure，
此时JVM启动备案，使用Serial Old进行full GC。
- G1(Garbage First)，提出基于Region的概念，将新生代、老年代划分为更小的单元Region，优先回收价值最大的Region，
从整体上看是基于标记-压缩，从Region局部看基于复制算法22


## 三、class类文件

class文件包含两种数据结构：无符号数和表

class文件结构：

```
魔数 版本号 常量池 访问标志 类/父类/接口 字段描述集合 方法描述集合 属性描述集合
```

![class文件结构](/img/post/class文件结构.png)

### 魔数
u4，ca fe ba be

### 版本号
u4，前两字节表示子版本号，后两字节表示主版本号，
如 00 01 00 34，表示52.1，即jdk 1.8.1

### 常量池
常量池是表集合，先是一个u2表示常量表个数，
每一项是单独的表，表的第一个u1大小都是tag，用于区分表类型，类型诸如
CONSTANT_utf8_info(字符串表)、CONSTANT_Integer_info(整型常量表)、CONSTANT_class_info(类/接口引用表)等

根据类型，可以查出表的结构，解析后面的数据，每个表可以表示出一个常量，如CONSTANT_utf8_info：

```
table CONSTANT_utf8_info {
    u1  tag;
    u2  length;
    u1[] bytes;
}
```

根据上图，tag=1时表示CONSTANT_utf8_info字符串表，
读取后续u2的地址数据，可以获取到字符串的长度length，
然后读取后续的length长度的地址，即该字符串的值。
因为预留了1位表示结束(ends with an instruction that is 1 byte long)，
于是String在编译期的最大长度为u2-2=65525-1=65534。
为什么不是65536-1？因为u2的最大值就是65535，最小值是0。

但是运行期String拼接可以比这个更长，但是String的诸多构造函数中，都受限于int的取值(数组的length是非负int)，
如果int溢出变成负数就会报错，所以运行期的上线就是int的最大值，也就是2^31-1(4G)

```
public final class String
    implements java.io.Serializable, Comparable<String>, CharSequence {
    private final int count;
    public int length() {...}
}
```

另外，这里也介绍下class常量表：

```
table CONSTANT_Class_info {
    u1  tag = 7;
    u2  name_index;
}
```

class常量表只有一个u2的name_index，这个值是个整型，指向当前class文件中该类的全限定名，
一定指向一个CONSTANT_utf8_info，比如"java/lang/Object"

### 访问标志
u2，是不同访问标志的或值(因为互不重叠，也就是累加和)，值对应如下：
![访问标志](/img/post/访问标志.png)
如0021表示最普通的单public标志(0x0001+0x0020，ACC_SUPER现在都是true)

### 类索引、父类索引与接口索引计数器
- 类索引u2，指向常量池中该类全限定名的位置
- 父类索引u2，指向常量池中该类父类全限定名的位置(java只支持单继承，所以只有一个父类)
- 接口索引计数器u2，该类实现了多少个接口，之后跟随指定数量个接口索引

### 字段描述集合
先是u2计数，之后跟随指定数个字段表，字段表结构如下：

```
CONSTANT_Fieldref_info{
    u2  access_flags        字段的访问标志
    u2  name_index          字段的名称索引(也就是变量名)
    u2  descriptor_index    字段的描述索引(也就是变量的类型)
    u2  attributes_count    属性计数器，下面再介绍
    attribute_info
}
```

### 方法描述集合
一样先是u2计数，之后跟随指定数个方法表，结构如下：

```
CONSTANT_Methodref_info{
    u2  access_flags;        方法的访问标志
    u2  name_index;          指向方法名的索引
    u2  descriptor_index;    指向方法类型的索引
    u2  attributes_count;    方法属性计数器
    attribute_info attributes;
}
```
其中descriptor_index包含了参数类型和返回类型，
如(Ljava/lang/String)V表示参数为String的无返回值方法


### 属性描述集合
可以放方法的Code属性，就是字节码了，还有异常表等。

```
属性名称	            使用位置	        说明
ConstantValue	    字段表	        final 关键字定义的常量值
Code	            方法表	        Java 代码编译的字节码指令
LineNumberTable	    Code 属性	    Java 源码的行号与字节码指令的对应关系
LocalVariableTable	Code 属性	    方法的局部变量描述
Exceptions	        方法表	        方法抛出的异常
SourceFile	        类文件	        源文件名称
InnerClasses	    类文件	        内部类列表
Synthetic	        类、方法表、属性表	标识方法或字段为编译器自动生成的

参https://www.cnblogs.com/binarylei/p/10508441.html
```


## 四、字节码技术

Transform API，是gradle中在编译生成class文件之后和生成dex文件之前的hack，

可通过Gradle插件来注册自定义的Transform，注册后的Transform会被Gradle包装成一个Gradle Task，
这个TransForm Task会在java compile Task执行完后运行

Transform提供了关键的transform方法：

```
public void transform(@NonNull
                      TransformInvocation transformInvocation)
```

可以从transformInvocation.inputs中拿到class的文件目录从而遍历class文件，然后采用字节码工具对字节码进行修改

AspectJ、ASM、Javassist框架是常用的字节码工具

AspectJ AOP框架提供五种注解：Before、After、AfterRunning、AfterThrowing、Around，
其中Around可以执行拦截，调用ProceedingJoinPoint.proceed()时才执行原方法，通过代理+runnable匿名内部类实现

Android上可使用aspectjx接入AspectJ，使用@Aspect注解的类，会被自动解析，类中可使用类似如下代码进行插桩

```
@Before("execution(* android.app.Activity.on**(..))")
public void onActivityMethodBefore(JoinPoint joinPoint) throws Throwable {
    String key = joinPoint.getSignature().toString();
    Log.d(TAG, "onActivityMethodBefore: " + key);
}
```

ASM使用Classworking，常用的API为ClassReader、ClassWriter

Javassist使用反射，比ASM慢，但接口比ASM丰富

参：https://blog.yorek.xyz/android/paid/master/bytecode/


## 五、ClassLoader

JVM的类加载器：为类文件生成一个java.lang.Class实例对象
- 启动类加载器BootstrapClassLoader
-- 加载%JAVA_HOME%/jre/classes目录下的类，由native代码实现，不是ClassLoader子类
- 扩展类加载器ExtClassLoader(jdk 1.9后改名为PlatformCLassLoader)
-- 加载%JAVA_HOME%/jre/lib/ext目录下的class，及java.ext.dirs系统变量指定的路径中类库，父类加载器为null
- 系统加载器APPClassLoader(或称应用类加载器)
-- 默认加载器，加载"java.class.path"目录下的类，即来自java命令中的classpath，以及java.class.path系统属性

加载过程：
1.检测该类是否被加载，已加载直接返回Class对象
2.如果有父类，先交给父类加载，如果父类为null，或者本身就是BootstrapCL，就先由BootstrapCL尝试加载
3.如果2没有加载成功，调用自身findClass方法加载，具体实现是defineClass，关键调用defineClass1是native方法
4.如果加载成功，返回Class对象；如果加载事变，抛出ClassNotFountException

Android中的ClassLoader
- Android将class文件转化为dex文件
- BootClassLoader是包访问权限，外部不能直接访问，是BaseDexClassLoader的实际parent
- BaseDexClassLoader负责加载dex文件，子类为PathClassLoader和DexClassLoader
- PathClassLoader只能加载已安装的apk的dex文件
- DexClassLoader可以加载未安装的dex文件，是热修复和热更新的基础


## 六、Class加载过程

装载 - 链接(验证、准备、解析) - 初始化

装载
1.生成二进制字节流：通过全限定名(包名+类名)查找.class文件，生成二进制流，查找来源：class文件、jar包、网络字节流
2.解析：把二进制流解析为JVM内部的数据结构，并存储在方法区
3.成功标志：在方法区生成java.lang.Class类型对象

链接
1.验证
- 文件格式验证：检查字节流是否符合class文件格式规范，校验版本当前虚拟机是否支持、校验常量池中tag类型是否合法
- 元数据校验：语义校验，是否有父类(除了Object外都有父类)、父类是否非final、如果非抽象是否已实现所有方法、重载语法是否正确
- 字节码校验：校验数据流、控制流，保证指令不会跳转到方法体以外的指令上、保证类型转化有效
- 符号引用校验：符号引用通过全限定名是否可找到对应的类、符号引用指定的字段/方法是否存在、字段/方法访问性是否合法
2.准备
- 为类的静态变量分配内存，final static赋初始值，普通static赋"0值"，普通static的赋值在初始化阶段
3.解析
- 把常量池中的符号引用转化为直接引用，即JVM会把常量池中的类、接口名、字段名、方法名转换为具体的内存地址

初始化
1.初始化即执行类构造器<clinit>方法的过程
(clinit是类构造器方法，init是对象构造器方法)，
即对static字段赋值，及执行static代码块
2.类的加载没有强制约束，必须初始化的时机为
2.1 调用类构造器(new指令)
2.2 调用类的静态变量或方法
2.3 反射调用，如Class.forName；
2.3 MethodHandle调用，更底层的"字节码"反射
2.4 初始化一个类的子类
2.5 JVM启动时参数中的启动类，这个类的main方法是程序的起点

- 以上均为主动引用，被动引用如
- final static的常量，如果编译器可以确定值，会被替换成常量，调用时不触发类初始化
- 如在父类定义static value，在其他位置调用子类Child.value访问时，只会触发父类初始化

对象创建顺序
1. 父类静态变量、静态块、
2. 子类静态变量、静态块
3. 父类普通成员变量、普通代码块
4. 父类构造函数
5. 子类普通成员变量、普通代码块
6. 子类构造函数


## 七、Java内存模型JMM

Java内存模型的目标是定义程序中各个变量的访问规则，即虚拟机将变量存储到内存和从内存中取出变量的底层细节。

这里说的变量包括实例字段、静态字段、构成数组对象的元素，不包括局部变量与方法参数。

```
java线程      工作内存

java线程      工作内存        save/load操作     主内存

java线程      工作内存

```

主内存与工作内存间的交互定义了以下8种操作：
1. lock
2. unlock
3. read     将变量值从主内存读到工作内存
4. load     将read到的值房主工作内存的变量中
5. use      将工作内存中的值传递给执行引擎
6. assign
7. store    将工作内存中变量的值传值主内存
8. write    将store带来的值放入主内存的变量中

- 缓存一致性问题：其他线程访问变量时，可能没有读到最新值
- 运行期指令重排：对线程中无依赖的指令进行重排序，以达到精简指令的效果

Java内存模型是一套共享内存的读写规范，屏蔽底层各种硬件与操作系统的访问差异，使各平台下Java程序对内存的访问效果一致

happens-before先行发生原则：如果操作A happens before操作B，那么A的执行结果对B可见
以下情况自动符合happens-before
- 程序次序原则：同一线程中，如果代码的字节码顺序在前的操作先执行
- 锁定规则：一个锁如果处于被锁定状态，必须unlock后才能进行lock操作
- 变量规则：volatile变量的写，对其他线程的读可见
- 线程启动规则：Thread的start发生在该线程的所有操作之前
- 线程中断规则：interrupt操作对所有catch InterruptException可见
- 线程终结规则：Thread的isAlive()返回值一定准确
- 对象终结规则：一个对象的初始化完成与finalize()前


## 八、同步

synchronized使用：
- 修饰实例方法：锁当前对象
- 修饰静态方法：锁当前类的Class对象
- 修饰代码块：锁括号中的参数对象

sync是可重入的，比如子类调用父类，访问同一个对象时不会死锁<br/>
可以用Object的wait/notify实现不可重入锁<br/>
作用于代码块时，编译成字节码对应monitorenter与monitorexit指令<br/>
作用于方法时，方法的flags会打上ACC_SYNCHRONIZED标志，在JVM访问时会增加上述两条指令<br/>

Reentrantlock：
- 可以指定公平锁(默认不公平，sync也是不公平)
- 支持读写锁

Java对象在内存中布局分为：对象头、实例数据、对齐填充，
对象头中包含了对象的hashCode、分代年龄、锁标志位、是否偏向锁等

Monitor是对象有中的一个对象，是重量级锁同步工具，记录了如下信息：
- _owner：指向持有ObjectMonitor对象的线程(当前获得锁的线程)
- WaitSet：处于wait状态的等待线程队列(获得锁的线程主动调wait()时进入)
- _EntryList：处于等待锁block状态的线程队列
- _count：记录线程读取锁的次数

锁的状态总共有四种：无锁、偏向锁、轻量级锁和重量级锁
- 锁自旋：线程先等待一段时间，不立即挂起，等待时执行一段无意义的循环，需占用CPU
- 偏向锁：当线程进入同步块时，锁的对象头记录下当前的ThreadId，下次线程获取锁时，
判断ThreadId是否一致，一致则不需再次获取锁直接执行，否则膨胀成重量级锁

参：https://www.cnblogs.com/paddix/p/5405678.html

AQS(Abstract Queued Synchronizer)抽象队列同步器

ReentrantLock内部通过一个Sync对象实现同步，Sync是一个抽象内部静态类，
extends AbstractQueuedSynchronizer，有NonfairSync和FairSync两种实现


## 九、线程池

```
可执行者
public interface Executor {
    void execute(Runnable command);
}

ExecutorService定义了提交机制与线程池关闭方法
public interface ExecutorService extends Executor {

}

ThreadPoolExecutor是ExecutorService的默认实现

ScheduledThreadPoolExecutor提供重复执行机制

```

```
// Executors工厂类

// 单线程
newSingleThreadExecutor()
// 可缓存池，回收复用，无可用时新建线程
newCachedThreadPool()
// 固定大小
newFixedThreadPool(int nThreads)
// 固定大小，重复执行池
newScheduledThreadPool(int corePoolSize)

// 执行完后，依次递增period延时再执行
ScheduledExecutorService.scheduleAtFixedRate(run, initialDelay, period, unit)
// 执行完后，使用固定delay延时执行
ScheduledExecutorService.scheduleWithFixedDelay(run, initialDelay, delay, unit)
```

```
public ThreadPoolExecutor(int corePoolSize,
                          int maximumPoolSize,
                          long keepAliveTime,
                          TimeUnit unit,
                          BlockingQueue<Runnable> workQueue,
                          ThreadFactory threadFactory,
                          RejectedExecutionHandler handler)

corePoolSize：核心线程数，最多可同时执行的线程数
maximumPoolSize：最大线程数，所有运行和等待线程的最大数，如果没有设置RejectedExecutionHandler，超过这个数时会抛出RejectedExecutionException
keepAliveTime：达到核心线程数数，切小于等于最大线程数时提交的Runnable，处于等待状态，等待的时长
unit：keepAliveTime的单位
workQueue：Runnable等待队列
threadFactory：线程工场，默认DefaultThreadFactory，默认指定与当前线程通过group，指定一个线程名，设置为非守护线程，优先级为NORM_PRIORITY
handler：超出maximumPoolSize时提交Runnable的处理器：void rejectedExecution(Runnable r, ThreadPoolExecutor executor);

RejectedExecutionException有4个子类(策略)：
AbortPolicy，默认策略，抛出RejectedExecutionException
DiscardPolicy，空实现，直接放弃，啥也不干
DiscardOldestPolicy，去掉队列里最老的任务，把新任务插入
CallerRunsPolicy，直接在当前线程调run()方法（退回给提交线程执行）
```

```
ThreadPoolExecutor
public void execute(Runnable command) {...}
public <T> Future<T> submit(Callable<T> task) {...}
submit有返回值Future，Future的get()方法可以阻塞等待执行结果
```

# 第二部分、Android

## 十、DVM Feature

dalvik虚拟机是基于寄存器的虚拟机，JVM是基于栈式虚拟机。寄存器式指令少、单条指令长，解释器执行更快速，栈式便于移植

DVM将内存分为Active Heap和Zygote Heap两块，因为所有进程都是从Zygote复制出来的，写时拷贝，避免频繁复制

manifest文件中可以指定android:largeHeap="true"申请使用大堆，大堆上限大小可通过ActivityManager.getLargeMemoryClass()读出

DVM采用JIT来将字节码转换成机器码，运行时解释；ART采用了AOT预编译技术，安装的时候就完成了字节码转换为机器码，占用空间更大

ART GC策略：
- ART 有多个不同的 GC 方案，涉及运行不同的垃圾回收器。从 Android 8 (Oreo) 开始，默认方案是并发复制 (CC)。另一个 GC 方案是并发标记清除 (CMS)。
- 在Android 10 及更高版本中，CC 回收器在分代模式下运行。
- CMS分为粘性(sticky)CMS和部分(partial)CMS，粘性CMS只回收上次GC后新分配的对象，CMS是不移动对象的GC，有内存碎片问题，通常在app退到后台后，Android会对内存进行压缩

参：https://source.android.google.cn/devices/tech/dalvik/gc-debug?hl=zh-cn


## 十、Activity启动

```
ActivityA - Instrument - AMS - ApplicationThread - ActivityB

Activity.startActivity
Activity.startActivityForResult
Instrumentation.execStartActivity
ActivityTaskManager.getService().startActivity
ActivityTaskManagerService.startActivity
ActivityTaskManagerService.startActivityAsUser
ActivityStarter.executeRequest(Request...)（以前叫startActivityMayWait）
ActivityStarter.startActivityUnchecked(ActivityRecord...)
ActivityStack.startActivityInner(ActivityRecord...) - startActivityLocked
ActivityRecord.showStartingWindow - addStartingWindow

ActivityManagerService.startProcessLocked
ActivityThread.main - attach - attachApplicationLocked - bindApplication

ActivityStack.realStartActivityLocked

ActivityThread.scheduleLaunchActivity - handleLaunchActivity - handleResumeActivity - Idler

ActivityStack.completeResumeLocked - activityIdleInternal - startPausingLocked
```


## 十一、Activity、Window、View关系

```
public void setContentView(@LayoutRes int layoutResID) {
    getWindow().setContentView(layoutResID);
    initWindowDecorActionBar();
}

public Window getWindow() {
    return mWindow;
}

// mWindow是在attach中创建的
final void attach(Context context, ActivityThread aThread,
            Instrumentation instr, IBinder token, ...) {
    attachBaseContext(context);
    mFragments.attachHost(null /*parent*/);
    mWindow = new PhoneWindow(this, window, activityConfigCallback);
    // ...
    mWindow.setWindowManager((WindowManager)context.getSystemService(Context.WINDOW_SERVICE), ...);
    // ...
}

// Window是抽象的，PhoneWindow是Window的唯一实现类
// Window的setWindowManager中，使用系统的WindowManager创建了一新的WindowManagerImpl

public void setWindowManager(WindowManager wm, IBinder appToken, String appName, boolean hardwareAccelerated) {
    // ...
    mWindowManager = ((WindowManagerImpl)wm).createLocalWindowManager(this);
}

public WindowManagerImpl createLocalWindowManager(Window parentWindow) {
    return new WindowManagerImpl(mContext, parentWindow);
}

// Window中setContentView是abstract的，PhoneWindow的实现如下：
public void setContentView(int layoutResID) {
    if (mContentParent == null) {
        installDecor();
    } else if (!hasFeature(FEATURE_CONTENT_TRANSITIONS)) {
        mContentParent.removeAllViews();
    }
    // ..
    mLayoutInflater.inflate(layoutResID, mContentParent);
    // ...
}

private void installDecor() {
    if (mDecor == null) {
        mDecor = generateDecor(-1);
        // ...
    }
    // ...
    if (mContentParent == null) {
        mContentParent = generateLayout(mDecor);
    }
    // ...
}

protected DecorView generateDecor(int featureId) {
    return new DecorView(context, featureId, this, getAttributes());
}

public class DecorView extends FrameLayout implements WindowCallbacks ...

protected ViewGroup generateLayout(DecorView decor) {
    // ...
    ViewGroup contentParent = ( `ViewGroup)findViewById(ID_ANDROID_CONTENT);
    // ...
    return contentParent;
}

总之，PhoneWindow中有一个DecorView mDecor，以及一个ViewGroup mContentParent，mContentParent = mDecor.fiid(android.R.id.content)
自定义的layout，由mLayoutInflater.inflate(layoutResID, mContentParent)添加至mContentParent下

真正把View当做窗口添加到WMS是有WindowManager的实现WindowManagerImpl完成的
WindowManagerImpl会调到WindowManagerGlobal的addView，
再通过ViewRootImpl的setView方法，先由requestLayout完成measure-layout-draw操作，
再调用mWindowSession.addToDisplay调到WMS中，之后的操作就交由WMS完成

public final class WindowManagerImpl implements WindowManager {
    private final WindowManagerGlobal mGlobal = WindowManagerGlobal.getInstance();
    public void addView(@NonNull View view, @NonNull ViewGroup.LayoutParams params) {
        applyDefaultToken(params);
        mGlobal.addView(view, params, mContext.getDisplay(), mParentWindow);
    }
}

public final class WindowManagerGlobal {
    private static IWindowSession sWindowSession = getWindowManagerService().openSession(...);
    public void addView(View view, ViewGroup.LayoutParams params, Display display, Window parentWindow) {
         ViewRootImpl root = new ViewRootImpl(view.getContext(), display);
    }
    try {
        root.setView(view, wparams, panelParentView);
    } catch (RuntimeException e) {
        // BadTokenException or InvalidDisplayException
        throw e;
    }
}

public class WindowManagerService extends IWindowManager.Stub {
    private static WindowManagerService sInstance;
    private WindowManagerService(...) {}
    public IWindowSession openSession(...) {
        // 第一个参数把WMS传到Session的成员变量mService里
        Session session = new Session(this, callback, client, inputContext);
        return session;
    }
}

public final class ViewRootImpl implements ViewParent... {
    mWindowSession = WindowManagerGlobal.getWindowSession();
    public void setView(View view, WindowManager.LayoutParams attrs, View panelParentView) {
        synchronized (this) {
            requestLayout();
            mWindowSession.addToDisplay(...);
            // 以下构造输入责任链，viewPostImeStage是责任链最后一个节点
            InputStage viewPostImeStage = new ViewPostImeInputStage(...);
        }
    }
}

class Session extends IWindowSession.Stub implements IBinder.DeathRecipient {
    final WindowManagerService mService;
    public int addToDisplay(IWindow window, ...) {
        mService.addWindow(this, window, ...);
    }
}

当触屏事件发生后，经过驱动层通过Socket跨进程通知Android Framework层WMS，最终消息以msg传到ViewRootImpl
ViewRootImpl在handleMessage中调用doProcessInputEvents，由deliverInputEvent传给setView中构造的input责任链
ViewPostImeInputStage的onProcess中，执行了handled = mView.dispatchPointerEvent(event)，将事件分发给了mView
mView一般就是传过来的DecorView，其复写方法如下：
public boolean dispatchTouchEvent(MotionEvent ev) {
    final Window.Callback cb = mWindow.getCallback();
    return cb != null && !mWindow.isDestroyed() && mFeatureId < 0
            ? cb.dispatchTouchEvent(ev) : super.dispatchTouchEvent(ev);
}
而其中Window.Callback，是Activity在attach方法中调用了mWindow.setCallBack(this)，设置为了自身
所以点击事件会优先传递到Activity上，其对应方法如下：
public boolean dispatchTouchEvent(MotionEvent ev) {
    if (ev.getAction() == MotionEvent.ACTION_DOWN) {
        onUserInteraction();
    }
    if (getWindow().superDispatchTouchEvent(ev)) {
        return true;
    }
    return onTouchEvent(ev);
}
可见，如果不复写Activity的该方法，会默认先走PhoneWindow的superDispatchTouchEvent，
实际调到DecorView的同名方法，DecorView调用parent(也就是ViewGroup)的dispatchTouchEvent，至此回到ViewGroup的事件传递过程
```


## 十二、touch事件分发

上节可知，点击事件先传递到Activity的dispatchTouchEvent，如果未处理，走入DecorView的传递

```
ViewGroup分发：

首先，持有ViewGroup实例的对象可以直接禁用其处理点击事件
public void requestDisallowInterceptTouchEvent(boolean disallowIntercept) {
    if (disallowIntercept) {
        mGroupFlags |= FLAG_DISALLOW_INTERCEPT;
    } else {
        mGroupFlags &= ~FLAG_DISALLOW_INTERCEPT;
    }
    if (mParent != null) {
        mParent.requestDisallowInterceptTouchEvent(disallowIntercept);
    }
}

ViewGroup的传递如下：
public void dispatchTouchEvent() {
    // 0.收到down事件时清空TouchTarget链表，mFirstTouchTarget置空
    if (actionMasked == MotionEvent.ACTION_DOWN) {
        resetTouchState();
    }
    // 1.检查当前ViewGroup是否要拦截事件
    // 如果不是down事件，且还没有子View申明过要处理touch事件，
    // 先判断是不是被禁用了，禁用则不拦截，否则再调用自身onInterceptTouchEvent看是否拦截
    final boolean intercepted;
    if (actionMasked == MotionEvent.ACTION_DOWN || mFirstTouchTarget != null) {
        boolean disallowIntercept = (mGroupFlags & FLAG_DISALLOW_INTERCEPT) != 0;
        if (!disallowIntercept) {
            intercepted = onInterceptTouchEvent(ev);
        } else {
            intercepted = false;
        }
    } else {
        intercepted = true;
    }
    ...
    // 2.将down事件分发给子View
    // 按层级从上往下遍历子View，如果发现某个View要处理点击事件，
    // 将其设为TouchTarget链表的头结点(mFirstTouchTarget)，并结束遍历
    if (!canceled && !intercepted) {
        // 这里注意，是down事件，或者多点触控中的point_down，或者鼠标move才走这个分支，如果是普通move/up等，直接去3
        if (actionMasked == MotionEvent.ACTION_DOWN
                || (split && actionMasked == MotionEvent.ACTION_POINTER_DOWN)
                || actionMasked == MotionEvent.ACTION_HOVER_MOVE)) {
            final View[] children = mChildren;
            for (int i = childrenCount - 1; i >= 0; i--) {
                // 需同时满足可接受事件(可见或动画中)、触摸点在View范围中(INVISIBLE时如在动画中，可以点击)
                if (!canViewReceivePointerEvents(child)
                        || !isTransformedTouchPointInView(x, y, child, null)) {
                    ev.setTargetAccessibilityFocus(false);
                    continue;
                }
                // 该dispatch方法会调用child.dispatchTouchEvent(event)继续传递
                if (dispatchTransformedTouchEvent(ev, false, child, idBitsToAssign)) {
                    newTouchTarget = addTouchTarget(child, idBitsToAssign);
                    alreadyDispatchedToNewTouchTarget = true;
                    break;
                }
            }
        }
    }
    ...
    // 3.根据mFirstTarget，再次分发事件
    // 如果mFirstTouchTarget为空，说明子View没有拦截事件，这里继续调dispatch，因为传入null会调父类的dispatch
    // 如果mFirstTouchTarget非空，如果已经在2中处理过了，跳过，如果还未处理，传递给链表中所有节点处理
    if (mFirstTouchTarget == null) {
        handled = dispatchTransformedTouchEvent(ev, canceled, null,
                TouchTarget.ALL_POINTER_IDS);
    } else {
        TouchTarget target = mFirstTouchTarget;
        while (target != null) {
            final TouchTarget next = target.next;
            if (alreadyDispatchedToNewTouchTarget && target == newTouchTarget) {
                handled = true;
            } else {
                final boolean cancelChild = resetCancelNextUpFlag(target.child)
                        || intercepted;
                if (dispatchTransformedTouchEvent(ev, cancelChild,
                        target.child, target.pointerIdBits)) {
                    handled = true;
                }
                // ...
             }
         }
    }
    ...
}

private boolean dispatchTransformedTouchEvent(MotionEvent event, View child, ...) {
    // ...
    if (child == null) {
        // 传入的child为空，调父类(就是View)的方法，实际会调到自身的onTouchEvent中
        handled = super.dispatchTouchEvent(event);
    } else {
        // 传入的child非空，传递给子类处理
        handled = child.dispatchTouchEvent(event);
    }
    // ...
}
```

```
View事件处理
上面我们看到，在子View都不处理点击时，最终会调用到super.dispatchTouchEvent
一般自定义的View如果需要处理touch，不推荐直接复写该方法，而是推荐处理onTouchEvent
View中方法如下：
public boolean dispatchTouchEvent(MotionEvent event) {
    ListenerInfo li = mListenerInfo;
    if (li != null && li.mOnTouchListener != null
            && (mViewFlags & ENABLED_MASK) == ENABLED
            && li.mOnTouchListener.onTouch(this, event)) {
        result = true;
    }
    if (!result && onTouchEvent(event)) {
        result = true;
    }
}

可以看到，会优先调用mOnTouchListener的onTouch方法，如果onTouch返回false，会继续调自身的onTouchEvent
View默认onTouchEvent如下，其中处理了我们常见的点击、长按等操作：
public boolean onTouchEvent(MotionEvent event) {
    // 这个代理可以用来实现扩大点击区域
    if (mTouchDelegate != null) {
        if (mTouchDelegate.onTouchEvent(event)) {
            return true;
        }
    }
    if (clickable) {
        switch (action) {
            case MotionEvent.ACTION_UP:
                // ...
                performClickInternal();
                // ...
            case MotionEvent.ACTION_DOWN:
                // ...
                checkForLongClick();
                // ...
        }
    }
}

```

至此，整个点击事件传递就陈述完了，简单图示如下：



## 十三、View的绘制

```
protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
    setMeasuredDimension(getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec),
            getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec));
}
参数中的int measureSpec高2位表示specMode，低30位表示具体数值
int specMode = MeasureSpec.getMode(measureSpec);
int specSize = MeasureSpec.getSize(measureSpec);

specMode值：
MeasureSpec.UNSPECIFIED：未指定，如ListView的item
MeasureSpec.EXACTLY：固定大小，match_parent或固定值
MeasureSpec.AT_MOST：wrap_content

setMeasuredDimension传入的值，在判断是视图否有阴影后，就会算出measureWidth和measureHeight

onMeasure是计算View的宽高，由measure方法调用，measure方法
可用View.MeasureSpec.makeMeasureSpec(0, View.MeasureSpec.UNSPECIFIED);计算measureSpec值

```


## 十四、Handler

```
public final class Looper {
    static final ThreadLocal<Looper> sThreadLocal = new ThreadLocal<Looper>();
    private static Looper sMainLooper;  // guarded by Looper.class
    final MessageQueue mQueue;
    final Thread mThread;

    private Looper(boolean quitAllowed) {
        mQueue = new MessageQueue(quitAllowed);
        mThread = Thread.currentThread();
    }

    public static void prepare() {
        prepare(true);
    }

    private static void prepare(boolean quitAllowed) {
        if (sThreadLocal.get() != null) {
            throw new RuntimeException("Only one Looper may be created per thread");
        }
        sThreadLocal.set(new Looper(quitAllowed));
    }

    // 这个方法是给ActivityThread的main方法调的，设置sMainLooper
    public static void prepareMainLooper() {
        prepare(false);
        synchronized (Looper.class) {
            if (sMainLooper != null) {
                throw new IllegalStateException("The main Looper has already been prepared.");
            }
            sMainLooper = myLooper();
        }
    }

    public static @Nullable Looper myLooper() {
        return sThreadLocal.get();
    }

    public static void loop() {
        final Looper me = myLooper();
        for (;;) {
            Message msg = queue.next(); // might block
            // ...
            // 这里的target就是handler
            msg.target.dispatchMessage(msg);
            // ...
        }
    }
}


public class Handler {

    public boolean sendMessageAtTime(Message msg, long uptimeMillis) {
        // ...
        return enqueueMessage(queue, msg, uptimeMillis);
    }

    private boolean enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis) {
        msg.target = this;  // 这里把target设置为了handler自身
        return queue.enqueueMessage(msg, uptimeMillis);
    }

    // handler.post会将runnable封装成一个msg添加到msg queue中，由此转换到handler所在线程执行.run()
    public final boolean post(Runnable r) {
       return sendMessageDelayed(getPostMessage(r), 0);
    }

    private static Message getPostMessage(Runnable r) {
        Message m = Message.obtain();
        m.callback = r;
        return m;
    }

    public void dispatchMessage(Message msg) {
        if (msg.callback != null) {
            handleCallback(msg);
        } else {
            // mCallback是构造函数传进来的
            if (mCallback != null) {
                if (mCallback.handleMessage(msg)) {
                    return;
                }
            }
            handleMessage(msg);
        }
    }

    // 空方法，由子类实现
    public void handleMessage(Message msg) {
    }

}

public final class Message implements Parcelable {
    long when;          // currentTimeMillis() + delay
    Handler target;     // 调用sendMessage的handler
    Message next;       // 单向链表
    // 设置为异步消息，普通消息默认是同步消息
    // 在MessageQueue调用postSyncBarrier后，只处理异步消息
    // 再次调用removeSyncBarrier后恢复处理普通消息，因此异步消息用于处理一些高优消息
    // 比如，ViewRootImpl中scheduleTraversals会调用postSyncBarrier，
    // 之后由Vsync发送的绘制消息会被优先执行，之后unscheduleTraversals会调removeSyncBarrier解除
    public void setAsynchronous(boolean async) {...}
}

public final class MessageQueue {

    boolean enqueueMessage(Message msg, long when) {
        // 主要是按时间when把msg插到Message链表中
        // 而取消息操作next()是Looper.loop()中调用的
    }

    Message next() {
        for (;;) {
            nativePollOnce(ptr, nextPollTimeoutMillis);
            if (now < msg.when) {
                // 下一条消息还没到点，带上超时值重新pollOnce
                nextPollTimeoutMillis = (int) Math.min(msg.when - now, Integer.MAX_VALUE);
            } else {
                return msg;
            }
            // 因为线程闲下来了没消息处理，就看下idle里有没有事务要处理，一次最多4个，这个可以用于启动优化
            for (int i = 0; i < pendingIdleHandlerCount; i++) {
                IdleHandler idler = mPendingIdleHandlers[i];
                boolean keep = idler.queueIdle();
                if (!keep) {
                    mIdleHandlers.remove(idler);
                }
            }
        }
    }

    public void addIdleHandler(@NonNull IdleHandler handler) {
        mIdleHandlers.add(handler);
    }
}

```


## 十五、OkHttp

```
RequestBody formBody = new FormBody.Builder().add("key", "value").build();

OkHttpClient client = new OkHttpClient.Builder()
    .addInterceptor(interceptor).proxy(proxy).cache(new Cache(...)).build();

Request request = new Request.Builder().url(url)
    .post(formBody).header("User-Agent", "Chrome").build();

client.newCall(request).enqueue(new CallBack(){
    public void onResponse(Call call, Response, response);
    public void onFailed(Call call, IOException);
});

public Call newCall(Request request) {
    return RealCall.newRealCall(...);
}

public void enqueue(Callback) {
    client.dispatcher().enqueue(new AsyncCall(callback));
}

public void enqueue() {
    executorService().execute(call);
}

public class AsyncCall extents NamedRunnable() {
    public final void run() {... execute(); ...}
    protected void execute() {
        try {
            Response response = getResponseWithInterceptorChain();
            callBack.onResponse();
        } catch (IOException e) {
            callBack.onFailure();
        }
    }
}

public Response getResponseWithInterceptorChain() {
    List<Interceptor> interceptors = new ArrayList();
    interceptors.addAll(client.interceptors);           // client外传入的
    interceptors.add(retryAndFollowUpInterceptor);      //
    interceptors.add(new BridgeInterceptor());          // 设置Head默认值，如Cookie
    interceptors.add(new CacheInterceptor());           //
    interceptors.add(new ConnectInterceptor());         // 建立TCP
    interceptors.add(new CallServerInterceptor());      // 从Server拿到远端回包
    Interceptor.Chain chain = new RealInterceptorChain(interceptors);
    return chain.proceed(originalRequest);
}

```


## 十六、RecyclerView四级缓存
```
public final class Recycler {
    // 屏幕内缓存，数据刷新时，不需要重新加载子ItemView，直接复用；
    final ArrayList<ViewHolder> mAttachedScrap = new ArrayList<>();
    ArrayList<ViewHolder> mChangedScrap = null;
    // 刚刚移出屏幕的缓存，最大容量为2，通过position来保存
    final ArrayList<ViewHolder> mCachedViews = new ArrayList<ViewHolder>();
    // 自定义缓存
    private ViewCacheExtension mViewCacheExtension;
    // 缓存池，保存第二级缓存中保存不了的ItemView。通过itemType来保存，每种itemType可以保存5个ItemView
    // 可以多个RecyclerView共享
    RecycledViewPool mRecyclerPool;

    static final int DEFAULT_CACHE_SIZE = 2;
    ...
}
```
```
自定义缓存RecyclerView对应方法如下：
public void setViewCacheExtension(@Nullable ViewCacheExtension extension) {
    mRecycler.setViewCacheExtension(extension);
}
public abstract static class ViewCacheExtension {
    public abstract View getViewForPositionAndType(@NonNull Recycler recycler, int position,
                    int type);
}
LayoutManager的实现中，layoutChunk调layoutState.next(Recycler)，此时recycler会调用getViewForPosition
进一步调到tryGetViewHolderForPositionByDeadline，
// 0) If there is a changed scrap, try to find from there
// 1) Find by position from scrap/hidden list/cache
// 2) Find from scrap/cache via stable ids, if exists
会尝试从传入的extension中取出holder复用
```


## 十七、apk安装过程与包体积优化

## 十八、android系统启动与app启动

## 十九、MAT使用、内存泄漏与LeakCanary原理

## 二十、异常捕获原理

## 二十一、UI卡顿优化
SysTrace

## 二十二、surface绘制原理

## xlog、mmap、nativePollOnce

## 其他

Bitmap.getByteCount()可返回实际占用字节数
缩放比例 scale = 当前设备屏幕密度density / 图片所在 drawable 目录对应屏幕密度density
屏幕像素密度densityDpi = 屏幕密度density * 160
density = PPI / 160
Bitmap 实际大小 = 宽 * scale * 高 * scale * Config 对应存储像素数
mdpi : 该像素密度对应 density = 1 , densityDpi = 160
hdpi : 该像素密度对应 density = 1.5 , densityDpi = 240
xhdpi : 该像素密度对应 density = 2 , densityDpi = 320
xxhdpi : 该像素密度对应 density = 3 , densityDpi = 480
通过asset目录加载，不会缩放

requestLayout
invalidate方法，如果View的位置并没有发生改变，则View不会触发重新布局的操作









