---
layout:     post
title:      设计模式基础八股(Android版).md
subtitle:   23种设计模式
date:       2021-09-23
author:     K
header-img: img/post-bg-desk.jpg
catalog: true
tags:
    - 设计模式
    - Android
    - Java
---

# 面向对象原则（SOLID）

- S（Single Responsibility Principle，简称 SRP）：单一职责原则，意思是对象应该仅具有一种单一的功能。
类的职责要单一

- O（Open–Closed Principle，简称 OCP）：开闭原则，也就是程序对于扩展开放，对于修改封闭。 
用继承(扩展)去修改

- L（Liskov Substitution Principle，简称 LSP）：里氏替换原则，程序中的对象应该是可以在不改变程序正确性的前提下被它的子类所替换的。
子类不能复写父类的非抽象方法，保证父类运行的正确性，这个在生产环境好像比较少见

- I（Interface Segregation Principle，简称 ISP）：接口隔离原则，多个特定客户端接口要好于一个宽泛用途的接口。
接口定义的职责要单一

- D（Dependency Inversion Principle，简称 DIP）：依赖反转原则，该原则认为一个方法应该遵从“依赖于抽象而不是一个实例”。
高层模块不应该依赖底层模块，二者都应该依赖于抽象；
抽象不应该依赖于细节，细节应该依赖于抽象
DIP-原则，IoC控制反转是遵从DIP原则的设计模式，DI是IoC的具体实现，比如定义一个日志接口，然后注入一个日志实现类

有的说法是五大设计原则，有的是六大设计原则，六就多一个迪米特法则

# 设计原则补充

简单原则（KISS, Keep It Simple and Stupid）
- 控制复杂度，但不是过分简洁，遵从规范、适时重构，但不要过早优化
- 补充：YAGNI 原则（You Ain't Gonna Need It），不要写“将来可能需要，但现在却用不上”的代码

单一原则（DRY, Don't Repeat Yourself）
- 提升代码的可重用性，但注意不要随时都在关心代码重用性、过度设计

最少原则（迪米特法则（Law of Demeter，简称 LoD）
- 又叫最少知识原则，核心思想是通过减少和不必要的类进行通信来降低代码耦合
- 一个类只应该与它直接相关的类通信
- 每一个类应该知道自己需要的最少知识
- 一个类需要调用另一个类的某一个方法的话，可以通过第三者转发这个调用

表达原则（Program Intently and Expressively，简称 PIE）
- 指编程时应该有清晰的编程意图，并通过代码明确地表达出来
- 核心思想：代码即文档

分离原则（SoC）

# 创建型设计模式 (用来创建对象的）

## 1、单例模式（Singleton Pattern）
- 饿汉式：在声明变量时就创建该实例
- 懒汉式：使用到时才创建实例，DCL：double checked locking，volatile防止重排序
- Object obj = new Object()，在jvm中对应
-- new #2 ： 这行指令是说在堆上的某个地址处开辟了一块空间作为Object对象
-- invokespecial #1 ：这行指令是说将对象里的成员变量进行赋值操作
-- astore_1 ：这行指令是说将栈里的obj与堆上的对象建立起引用关联
-- invokespecial和astore_1可能重拍，导致初始化过程中其他线程get不为空，但此时还未初始化完毕
- volatile 变量规则：写入 volatile 变量 Happens Before 读取该变量
```
public class Singleton {
    private Singleton() {}
    private static volatile Singleton INSTANCE;
    public static Singleton getInstance() {
        if (sInstance == null) {
            synchronized (Singleton.class) {
                if (sInstance == null) {
                    sInstance = new Singleton();
                }
            }
        }
        return INSTANCE;
    }
}
// 注：同一个类的所有static synchronized方法同一时刻只有一个能执行；同一个对象的所有synchronized方法同一时刻只有一个能执行
```
```
// 静态内部类：clinit()线程安全
public class Singleton {
    private Singleton() {}
    private static class InnerClass { private static Singleton INSTANCE = new Singleton(); }
    public static Singleton getInstance() {
        return InnerClass.INSTANCE;
    }
}
```
```
// 枚举：避免反射
public eunm Singleton {
    INSTANCE;
    // ...其他属性及方法
}
```
```
// kotlin
public class Singleton {
    companion object {
        val INSTANCE by lazy(LazyThreadSafetyMode.SYNCHRONIZED){
            Singleton()
        }
    }
}
```

## 2、工厂模式（Factory Pattern）
用type创建对象实例
switch-case

## 3、抽象工厂模式（Abstract Factory Pattern）
工厂模式是type到实例的一维映射，工厂是静态的或实例，同一场景只有一个工厂实现
抽象工厂模式是二维映射，工厂本身是接口，同一场景有不同的工厂实现

## 4、原型模式（Prototype Pattern）
快速拷贝生成一个新对象，要注意深浅拷贝
Object没有实现Cloneable，但有一个clone方法，是浅拷贝

## 5、建造者模式（Builder Pattern）
使用多个简单的对象一步一步构建成一个复杂的对象，一般构造函数参数太多的时候用


# 结构型设计模式 (关注类和对象的组合）
## 6、代理模式（Proxy Pattern）





