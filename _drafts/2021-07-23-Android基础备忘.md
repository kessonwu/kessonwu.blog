---
layout:     post
title:      Android基础备忘
subtitle:   全面回顾
date:       2021-07-23
author:     K
header-img: img/post-bg-desk.jpg
catalog: true
tags:
    - Android
---

# 第一部分、Java基础

# 一、内存分配

方法区、堆、虚拟机栈、本地方法栈、程序计数器

其中方法区、堆为公共内存区域，虚拟机栈、本地方法栈、程序计数器为线程私有

## 1 程序计数器PC

记录正在执行的虚拟机字节码指令的地址，线程切换时，处理器根据PC还原到需执行的位置

JVM基于栈，DVM基于寄存器，栈指令紧凑，寄存器指令长但指令数少(比如少了压/出栈指令)

## 2 虚拟机栈

虚拟机栈是线程私有的，是由栈帧组成的栈，栈顶帧为活动栈，
方法调用其他方法时，会将对应栈帧压倒栈顶，执行完后弹出，直至所有栈帧弹出，线程结束

栈帧是用于给虚拟机进行方法调用和方法执行的**数据结构**，每个方法调用产生一个栈帧，
每个栈帧包含局部变量表、操作数栈、动态链接、返回地址等，一个栈帧对应一个方法，对应多条指令(操作数)

动态链接是指向运行时常量池的方法引用，支持方法调用过程中将class文件中的符号引用转化为直接引用

class文件中的符号引用，在类解析阶段，或第一次使用时转化未直接引用，称为静态解析；在运行时转化为直接引用，称为动态链接

返回地址保存了方法正常退出时的PC计数值，方法异常退出时，返回地址是异常处理器表确定的，不保存在栈帧中

本地方法栈与虚拟机栈类似，只不过针对native方法

## 4 堆

方法的实例都分配在此区域，是垃圾回收GC管理的主要区域，一般分为新生代和老年代，新生代又分为eden、survivor0、survivor1

## 5 方法区

存储已被JVM加载的类信息(版本、字段、方法、接口)、常量、静态变量、代码

方法区是规范层的定义，永久区是HotSpot在JDK1.7及以下的实现，1.8后改为元空间实现


# 二、GC回收

## 可达性分析

JVM把内存中对象之间的引用关系看做一张图(离散图论)，由多颗有向树组成，树的根节点称为GC Root

从GC Root开始向下搜索，搜索所经过的路径称为引用链，通过引用链是否可达来判断对象是否可以回收

GC Root包括以下对象：
- 虚拟机栈中本地变量表所引用的对象
- 本地方法栈中本地变量表所引用的对象
- 方法区中静态引用指向的对象(包括常量)
- 仍处于存活状态的线程对象

回收时机：因内存不足导致的内存分配失败、主动调用System.gc()

## 内存回收算法

标记清除 Mark and Sweep
- 标记：从GC Root开始全部遍历，被引用的标记为灰色(存活)，否则标记成黑色(垃圾)
- 清除：遍历完成后，将垃圾全部清除
实现简单，不需要进行对象移动；需要stop the world，会产生内存碎片

复制算法 Copying
- 内存分为两块，一次用一块
- 在用的一块进行标记
- 标记完存活的全部拷贝到另一块
- 切换第二块为使用内存，并清除之前块的所有对象
无内存碎片；内存会缩小为一半，存活率高时复制频繁

标记-压缩 Mark-Compact
- 标记：同标记清除
- 压缩：将存活对象按顺序压缩到内存另一端
无内存碎片，不需要内存减半；仍然有对象移动，效率一般

分代回收机制
JVM一半分为新生代、老年代，HotSpot多定义了一个永久代<br>
新生代默认按8:1:1分为eden、survivor0、survivor1<br>
一般新生代因为存活率低采用复制算法，老年代采用MS或MC

## GC称谓
- young GC/minor GC: 回收新生代
- old GC: 回收老年代
- full GC: 收集整个堆

## Hotspot回收器
- Serial(JDK1.3之前)，单线程，用于新生代，复制算法，一旦启动，stop the world，多用于client
- Serial Old，用于老年代，标记清除算法，其余同上
- ParNew，Serial的多线程版本，同样也要stop all
- CMS(Concurrent Mark Sweep，JDK1.5起)，初始标记、并发标记、重新标记、并发清除，其中初标和重标仍然需要stop，其余可与用户程序
并发工作。CMS无法处理浮动垃圾，即并发运行的用户程序在标记过程中产生的垃圾。
CMS需预留一些空间进行整理，如果预留空间不足，则会抛出Concurrent Mode Failure，
此时JVM启动备案，使用Serial Old进行full GC。
- G1(Garbage First)，提出基于Region的概念，将新生代、老年代划分为更小的单元Region，优先回收价值最大的Region，
从整体上看是基于标记-压缩，从Region局部看基于复制算法22


# 三、class类文件

class文件包含两种数据结构：无符号数和表

class文件结构：

```
魔数 版本号 常量池 访问标志 类/父类/接口 字段描述集合 方法描述集合 属性描述集合
```

![class文件结构](/img/post/class文件结构.png)

## 魔数
u4，ca fe ba be

## 版本号
u4，前两字节表示子版本号，后两字节表示主版本号，
如 00 01 00 34，表示52.1，即jdk 1.8.1

## 常量池
常量池是表集合，先是一个u2表示常量表个数，
每一项是单独的表，表的第一个u1大小都是tag，用于区分表类型，类型诸如
CONSTANT_utf8_info(字符串表)、CONSTANT_Integer_info(整型常量表)、CONSTANT_class_info(类/接口引用表)等

根据类型，可以查出表的结构，解析后面的数据，每个表可以表示出一个常量，如CONSTANT_utf8_info：

```
table CONSTANT_utf8_info {
    u1  tag;
    u2  length;
    u1[] bytes;
}
```

根据上图，tag=1时表示CONSTANT_utf8_info字符串表，
读取后续u2的地址数据，可以获取到字符串的长度length，
然后读取后续的length长度的地址，即该字符串的值。
因为预留了1位表示null，于是String在编译期的最大长度为u2-2=65525-1=65534。
为什么不是65536-1？因为u2的最大值就是65535，最小值是0。

但是运行期String拼接可以比这个更长，但是String的诸多构造函数中，都受限于int的取值，
如果int溢出变成负数就会报错，所以运行期的上线就是int的最大值，也就是2^31-1(4G)

另外，这里也介绍下class常量表：

```
table CONSTANT_Class_info {
    u1  tag = 7;
    u2  name_index;
}
```

class常量表只有一个u2的name_index，这个值是个整型，指向当前class文件中该类的全限定名，
一定指向一个CONSTANT_utf8_info，比如"java/lang/Object"

## 访问标志
u2，是不同访问标志的或值(因为互不重叠，也就是累加和)，值对应如下：
![访问标志](/img/post/访问标志.png)
如0021表示最普通的单public标志(0x0001+0x0020，ACC_SUPER现在都是true)

## 类索引、父类索引与接口索引计数器
- 类索引u2，指向常量池中该类全限定名的位置
- 父类索引u2，指向常量池中该类父类全限定名的位置(java只支持单继承，所以只有一个父类)
- 接口索引计数器u2，该类实现了多少个接口，之后跟随指定数量个接口索引

## 字段描述集合
先是u2计数，之后跟随指定数个字段表，字段表结构如下：

```
CONSTANT_Fieldref_info{
    u2  access_flags        字段的访问标志
    u2  name_index          字段的名称索引(也就是变量名)
    u2  descriptor_index    字段的描述索引(也就是变量的类型)
    u2  attributes_count    属性计数器，下面再介绍
    attribute_info
}
```

## 方法描述集合
一样先是u2计数，之后跟随指定数个方法表，结构如下：

```
CONSTANT_Methodref_info{
    u2  access_flags;        方法的访问标志
    u2  name_index;          指向方法名的索引
    u2  descriptor_index;    指向方法类型的索引
    u2  attributes_count;    方法属性计数器
    attribute_info attributes;
}
```
其中descriptor_index包含了参数类型和返回类型，
如(Ljava/lang/String)V表示参数为String的无返回值方法


## 属性描述集合
可以放方法的Code属性，就是字节码了，还有异常表等。

```
属性名称	            使用位置	        说明
ConstantValue	    字段表	        final 关键字定义的常量值
Code	            方法表	        Java 代码编译的字节码指令
LineNumberTable	    Code 属性	    Java 源码的行号与字节码指令的对应关系
LocalVariableTable	Code 属性	    方法的局部变量描述
Exceptions	        方法表	        方法抛出的异常
SourceFile	        类文件	        源文件名称
InnerClasses	    类文件	        内部类列表
Synthetic	        类、方法表、属性表	标识方法或字段为编译器自动生成的

参https://www.cnblogs.com/binarylei/p/10508441.html
```

四、














